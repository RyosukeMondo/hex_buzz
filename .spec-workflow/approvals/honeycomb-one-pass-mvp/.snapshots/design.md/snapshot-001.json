{
  "id": "snapshot_1764279838412_wfn5x9gt0",
  "approvalId": "approval_1764279838410_13u33z0nz",
  "approvalTitle": "Design - Honeycomb One Pass MVP",
  "version": 1,
  "timestamp": "2025-11-27T21:43:58.412Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document - Honeycomb One Pass MVP\n\n## Overview\n\nThis design document describes the technical implementation of the Honeycomb One Pass MVP - a one-stroke puzzle game on a hexagonal grid. The MVP focuses on core gameplay for web platform with AI Agent-first development (CLI/REST API before UI).\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Flutter/Dart**: Cross-platform framework, web target for MVP\n- **Clean Architecture**: Domain logic separated from UI\n- **Development Principles**: KISS prioritized - minimal abstractions, simple implementations\n- **Pre-commit**: 500 lines/file, 50 lines/function, complexity < 10\n\n### Project Structure (structure.md)\n- `lib/domain/` - Game logic (no Flutter dependencies)\n- `lib/presentation/` - Flutter UI widgets\n- `lib/debug/` - REST API and CLI\n- `lib/core/` - Logging and utilities\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **None** - This is a greenfield MVP project\n\n### Integration Points\n- **Flutter Canvas API**: For hexagonal grid rendering\n- **shelf package**: For REST API server\n- **args package**: For CLI argument parsing\n\n## Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Presentation Layer\"\n        GS[GameScreen]\n        HG[HexGridWidget]\n        PP[PathPainter]\n    end\n\n    subgraph \"Domain Layer\"\n        GE[GameEngine]\n        PV[PathValidator]\n        LV[LevelValidator]\n        GM[GameModels]\n    end\n\n    subgraph \"Debug Layer\"\n        API[REST API Server]\n        CLI[CLI Runner]\n    end\n\n    subgraph \"Core Layer\"\n        LOG[Logger]\n        CONST[Constants]\n    end\n\n    GS --> HG\n    GS --> GE\n    HG --> PP\n    HG --> GM\n\n    GE --> PV\n    GE --> GM\n    GE --> LOG\n\n    API --> GE\n    CLI --> LV\n    CLI --> GE\n\n    LV --> GM\n    PV --> GM\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: One model/service per file\n- **Component Isolation**: HexGrid rendering isolated from game logic\n- **Service Layer Separation**: GameEngine handles state, PathValidator handles rules\n- **Utility Modularity**: Logging in core/, not mixed with domain\n\n## Components and Interfaces\n\n### HexCell (Model)\n- **Purpose**: Represents a single hexagonal cell in the grid\n- **Location**: `lib/domain/models/hex_cell.dart`\n```dart\nclass HexCell {\n  final int q;           // Axial coordinate q\n  final int r;           // Axial coordinate r\n  final int? checkpoint; // Checkpoint number (null if none)\n  bool visited;          // Has been visited in current path\n}\n```\n\n### Level (Model)\n- **Purpose**: Represents a puzzle level configuration\n- **Location**: `lib/domain/models/level.dart`\n```dart\nclass Level {\n  final int size;                    // Grid size (e.g., 4 for 4x4)\n  final List<HexCell> cells;         // All cells in the grid\n  final List<int> checkpointOrder;   // [1, 2, 3...] checkpoint sequence\n}\n```\n\n### GameState (Model)\n- **Purpose**: Represents current game state\n- **Location**: `lib/domain/models/game_state.dart`\n```dart\nclass GameState {\n  final Level level;\n  final List<HexCell> path;          // Current drawn path\n  final int nextCheckpoint;          // Next checkpoint to reach\n  final DateTime? startTime;         // When player started\n  final DateTime? endTime;           // When player completed (null if not done)\n  final bool isComplete;             // Win condition met\n}\n```\n\n### GameEngine (Service)\n- **Purpose**: Core game state machine - handles moves, undo, reset\n- **Location**: `lib/domain/services/game_engine.dart`\n- **Interfaces**:\n  - `GameState get state` - Current game state\n  - `bool tryMove(HexCell target)` - Attempt move to cell\n  - `void undo()` - Remove last path segment\n  - `void reset()` - Reset level to initial state\n- **Dependencies**: PathValidator, Logger\n- **Requirements**: REQ-003, REQ-004, REQ-005, REQ-006, REQ-007\n\n### PathValidator (Service)\n- **Purpose**: Validates if a move is legal\n- **Location**: `lib/domain/services/path_validator.dart`\n- **Interfaces**:\n  - `bool isValidMove(GameState state, HexCell target)` - Check move validity\n  - `bool isAdjacent(HexCell a, HexCell b)` - Check cell adjacency\n  - `bool checkWinCondition(GameState state)` - Check if puzzle solved\n- **Dependencies**: None (pure functions)\n- **Requirements**: REQ-004, REQ-007\n\n### LevelValidator (Service)\n- **Purpose**: Validates if a level is solvable (for CLI)\n- **Location**: `lib/domain/services/level_validator.dart`\n- **Interfaces**:\n  - `ValidationResult validate(Level level)` - Check solvability\n  - `List<HexCell>? findSolution(Level level)` - Find solution path\n- **Dependencies**: PathValidator\n- **Requirements**: REQ-009\n\n### HexGridWidget (UI)\n- **Purpose**: Renders hexagonal grid and handles touch input\n- **Location**: `lib/presentation/widgets/hex_grid/hex_grid_widget.dart`\n- **Interfaces**:\n  - `onCellTap(HexCell cell)` - Callback for cell interaction\n  - `onDragUpdate(HexCell cell)` - Callback for drag over cell\n- **Dependencies**: GameState (read-only), PathPainter\n- **Requirements**: REQ-001, REQ-002, REQ-003\n\n### PathPainter (UI)\n- **Purpose**: Draws the path with color gradient effect\n- **Location**: `lib/presentation/widgets/hex_grid/path_painter.dart`\n- **Interfaces**:\n  - `void paint(Canvas canvas, List<HexCell> path)` - Draw path\n- **Dependencies**: None\n- **Requirements**: REQ-003\n\n### GameScreen (UI)\n- **Purpose**: Main game screen with grid and reset button\n- **Location**: `lib/presentation/screens/game/game_screen.dart`\n- **Interfaces**: None (top-level screen)\n- **Dependencies**: HexGridWidget, GameEngine (via Provider)\n- **Requirements**: REQ-006, REQ-007\n\n### REST API Server (Debug)\n- **Purpose**: HTTP endpoints for AI agent interaction\n- **Location**: `lib/debug/api/server.dart`\n- **Endpoints**:\n  - `GET /api/game/state` - Returns GameState as JSON\n  - `POST /api/game/move` - Body: `{\"q\": int, \"r\": int}` - Execute move\n  - `POST /api/game/reset` - Reset level\n- **Dependencies**: GameEngine, shelf\n- **Requirements**: REQ-008\n\n### CLI Runner (Debug)\n- **Purpose**: Command-line interface for level validation\n- **Location**: `lib/debug/cli/cli_runner.dart`\n- **Commands**:\n  - `validate --level <json>` - Validate level solvability\n- **Dependencies**: LevelValidator, args\n- **Requirements**: REQ-009\n\n## Data Models\n\n### HexCell\n```dart\nclass HexCell {\n  final int q;           // Axial q coordinate (-size to +size)\n  final int r;           // Axial r coordinate (-size to +size)\n  final int? checkpoint; // 1, 2, 3... or null\n  bool visited;          // Mutable: path tracking\n\n  // Computed: pixel position for rendering\n  Offset toPixel(double cellSize);\n\n  // Computed: list of 6 adjacent cells\n  List<(int, int)> get neighbors;\n}\n```\n\n### Level\n```dart\nclass Level {\n  final String id;\n  final int size;\n  final Map<(int, int), HexCell> cells;  // Indexed by (q, r)\n  final int checkpointCount;\n\n  HexCell? getCell(int q, int r);\n  HexCell get startCell;  // Checkpoint 1\n  HexCell get endCell;    // Highest checkpoint\n}\n```\n\n### GameState\n```dart\nclass GameState {\n  final Level level;\n  final List<HexCell> path;\n  final int nextCheckpoint;\n  final DateTime? startTime;\n  final DateTime? endTime;\n\n  bool get isStarted => path.isNotEmpty;\n  bool get isComplete => endTime != null;\n  Duration? get elapsedTime;\n\n  // Immutable state updates\n  GameState copyWith({...});\n}\n```\n\n### API Response Models\n```dart\nclass GameStateResponse {\n  final String levelId;\n  final int gridSize;\n  final List<CellResponse> cells;\n  final List<PathSegment> path;\n  final int nextCheckpoint;\n  final bool isComplete;\n  final int? elapsedMs;\n}\n\nclass MoveRequest {\n  final int q;\n  final int r;\n}\n\nclass MoveResponse {\n  final bool success;\n  final String? error;\n  final GameStateResponse? state;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Invalid Move Attempt (UI)**\n   - **Handling**: PathValidator returns false, move ignored silently\n   - **User Impact**: No visual change, path stays as-is\n\n2. **Invalid Move Attempt (API)**\n   - **Handling**: Return 400 with error JSON `{\"error\": \"Invalid move\", \"reason\": \"...\"}`\n   - **User Impact**: AI agent receives structured error\n\n3. **Level Load Failure**\n   - **Handling**: Fall back to hardcoded default level\n   - **User Impact**: Game still playable, log warning\n\n4. **API Server Startup Failure**\n   - **Handling**: Log error, continue without API (UI-only mode)\n   - **User Impact**: Game works, API unavailable\n\n## Testing Strategy\n\n### Unit Testing\n- **PathValidator**: Test all adjacency cases, checkpoint order validation\n- **GameEngine**: Test move, undo, reset state transitions\n- **LevelValidator**: Test solvability detection, solution finding\n- **Coverage target**: 80% for domain layer\n\n### Integration Testing\n- **REST API**: Test all endpoints with mock GameEngine\n- **CLI**: Test validate command with sample levels\n\n### End-to-End Testing\n- **Web gameplay**: Complete a level via touch/mouse\n- **API gameplay**: Complete a level via REST API calls\n\n### Test File Structure\n```\ntest/\n├── domain/\n│   ├── models/\n│   │   ├── hex_cell_test.dart\n│   │   ├── level_test.dart\n│   │   └── game_state_test.dart\n│   └── services/\n│       ├── path_validator_test.dart\n│       ├── game_engine_test.dart\n│       └── level_validator_test.dart\n├── debug/\n│   ├── api/\n│   │   └── server_test.dart\n│   └── cli/\n│       └── cli_runner_test.dart\n└── presentation/\n    └── widgets/\n        └── hex_grid_widget_test.dart\n```\n",
  "fileStats": {
    "size": 9555,
    "lines": 323,
    "lastModified": "2025-11-27T21:43:54.188Z"
  },
  "comments": []
}