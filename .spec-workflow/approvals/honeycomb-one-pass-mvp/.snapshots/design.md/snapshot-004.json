{
  "id": "snapshot_1764280902959_q9lqet9y8",
  "approvalId": "approval_1764280763820_gteoe57qp",
  "approvalTitle": "Design - Honeycomb One Pass MVP (Revised with Level Identity)",
  "version": 4,
  "timestamp": "2025-11-27T22:01:42.959Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document - Honeycomb One Pass MVP\n\n## Overview\n\nThis design document describes the technical implementation of the Honeycomb One Pass MVP - a one-stroke puzzle game on a hexagonal grid. The MVP focuses on core gameplay for web platform with AI Agent-first development (CLI/REST API before UI).\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Flutter/Dart**: Cross-platform framework, web target for MVP\n- **Clean Architecture**: Domain logic separated from UI\n- **Development Principles**: KISS prioritized - minimal abstractions, simple implementations\n- **Pre-commit**: 500 lines/file, 50 lines/function, complexity < 10\n\n### Project Structure (structure.md)\n- `lib/domain/` - Game logic (no Flutter dependencies)\n- `lib/presentation/` - Flutter UI widgets\n- `lib/debug/` - REST API and CLI\n- `lib/core/` - Logging and utilities\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **None** - This is a greenfield MVP project\n\n### Integration Points\n- **Flutter Canvas API**: For hexagonal grid rendering\n- **shelf package**: For REST API server\n- **args package**: For CLI argument parsing\n\n## Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Presentation Layer\"\n        GS[GameScreen]\n        HG[HexGridWidget]\n        PP[PathPainter]\n    end\n\n    subgraph \"Domain Layer\"\n        GE[GameEngine]\n        PV[PathValidator]\n        LV[LevelValidator]\n        GM[GameModels]\n    end\n\n    subgraph \"Debug Layer\"\n        API[REST API Server]\n        CLI[CLI Runner]\n    end\n\n    subgraph \"Core Layer\"\n        LOG[Logger]\n        CONST[Constants]\n    end\n\n    GS --> HG\n    GS --> GE\n    HG --> PP\n    HG --> GM\n\n    GE --> PV\n    GE --> GM\n    GE --> LOG\n\n    API --> GE\n    CLI --> LV\n    CLI --> GE\n\n    LV --> GM\n    PV --> GM\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: One model/service per file\n- **Component Isolation**: HexGrid rendering isolated from game logic\n- **Service Layer Separation**: GameEngine handles state, PathValidator handles rules\n- **Utility Modularity**: Logging in core/, not mixed with domain\n\n## Components and Interfaces\n\n### HexCell (Model)\n- **Purpose**: Represents a single hexagonal cell in the grid\n- **Location**: `lib/domain/models/hex_cell.dart`\n```dart\nclass HexCell {\n  final int q;           // Axial coordinate q\n  final int r;           // Axial coordinate r\n  final int? checkpoint; // Checkpoint number (null if none)\n  bool visited;          // Has been visited in current path\n}\n```\n\n### HexEdge (Model)\n- **Purpose**: Represents an edge between two adjacent cells (for walls)\n- **Location**: `lib/domain/models/hex_edge.dart`\n```dart\n/// Represents an edge between two adjacent hex cells.\n/// Edges are undirected: HexEdge(A, B) == HexEdge(B, A)\nclass HexEdge {\n  final (int, int) cell1;  // (q, r) of first cell\n  final (int, int) cell2;  // (q, r) of second cell (must be adjacent)\n\n  // Canonical form ensures cell1 < cell2 for equality comparison\n  HexEdge.canonical(this.cell1, this.cell2);\n}\n```\n\n### Level (Model)\n- **Purpose**: Represents a puzzle level configuration with walls\n- **Location**: `lib/domain/models/level.dart`\n```dart\nclass Level {\n  final String id;                   // Unique hash of level structure\n  final int size;                    // Grid size (e.g., 4 for 4x4)\n  final List<HexCell> cells;         // All cells in the grid\n  final Set<HexEdge> walls;          // Edges where passage is blocked\n  final List<int> checkpointOrder;   // [1, 2, 3...] checkpoint sequence\n\n  /// Compute canonical hash for level identity (for DB storage/deduplication)\n  String computeHash();\n}\n```\n\n**Wall Concept**:\n- A wall is placed on an **edge** between two adjacent cells\n- If a wall exists between cell A and cell B, the player cannot move between them\n- Walls enable level generation to constrain paths and guarantee exactly one solution\n- Visually rendered as thick lines on cell boundaries\n\n**Level Identity (for Future Leaderboard)**:\n- Each level has a deterministic hash computed from: size, checkpoint positions, wall positions\n- Hash enables:\n  - **DB storage**: Store playable levels with their hash as primary key\n  - **Duplicate detection**: Reject identical levels during generation\n  - **Daily challenge**: All users play the same level (fetched by date)\n  - **Practice mode**: Instantly generated levels (not stored in leaderboard)\n\n### GameMode (Enum)\n- **Purpose**: Distinguishes ranked vs practice play\n- **Location**: `lib/domain/models/game_mode.dart`\n```dart\nenum GameMode {\n  daily,     // Today's global challenge - scores go to leaderboard\n  practice,  // Instant random generation - no leaderboard\n}\n```\n\n**Future Use**:\n- MVP: Practice mode only (no backend)\n- Post-MVP: Daily mode fetches level from server, submits completion time\n\n### GameState (Model)\n- **Purpose**: Represents current game state\n- **Location**: `lib/domain/models/game_state.dart`\n```dart\nclass GameState {\n  final Level level;\n  final List<HexCell> path;          // Current drawn path\n  final int nextCheckpoint;          // Next checkpoint to reach\n  final DateTime? startTime;         // When player started\n  final DateTime? endTime;           // When player completed (null if not done)\n  final bool isComplete;             // Win condition met\n}\n```\n\n### GameEngine (Service)\n- **Purpose**: Core game state machine - handles moves, undo, reset\n- **Location**: `lib/domain/services/game_engine.dart`\n- **Interfaces**:\n  - `GameState get state` - Current game state\n  - `bool tryMove(HexCell target)` - Attempt move to cell\n  - `void undo()` - Remove last path segment\n  - `void reset()` - Reset level to initial state\n- **Dependencies**: PathValidator, Logger\n- **Requirements**: REQ-003, REQ-004, REQ-005, REQ-006, REQ-007\n\n### PathValidator (Service)\n- **Purpose**: Validates if a move is legal (considering walls)\n- **Location**: `lib/domain/services/path_validator.dart`\n- **Interfaces**:\n  - `bool isValidMove(GameState state, HexCell target)` - Check move validity\n  - `bool isAdjacent(HexCell a, HexCell b)` - Check cell adjacency\n  - `bool isPassable(Level level, HexCell from, HexCell to)` - Check no wall blocks path\n  - `bool checkWinCondition(GameState state)` - Check if puzzle solved\n- **Dependencies**: None (pure functions)\n- **Requirements**: REQ-004, REQ-007\n\n**Move Validation Logic**:\n1. Target cell must be adjacent to current cell\n2. No wall between current cell and target cell\n3. Target cell not already visited\n4. If target has checkpoint, it must be the next expected checkpoint\n\n### LevelValidator (Service)\n- **Purpose**: Validates if a level is solvable (for CLI)\n- **Location**: `lib/domain/services/level_validator.dart`\n- **Interfaces**:\n  - `ValidationResult validate(Level level)` - Check solvability\n  - `List<HexCell>? findSolution(Level level)` - Find solution path\n- **Dependencies**: PathValidator\n- **Requirements**: REQ-009\n\n### HexGridWidget (UI)\n- **Purpose**: Renders hexagonal grid and handles touch input\n- **Location**: `lib/presentation/widgets/hex_grid/hex_grid_widget.dart`\n- **Interfaces**:\n  - `onCellTap(HexCell cell)` - Callback for cell interaction\n  - `onDragUpdate(HexCell cell)` - Callback for drag over cell\n- **Dependencies**: GameState (read-only), PathPainter\n- **Requirements**: REQ-001, REQ-002, REQ-003\n\n### PathPainter (UI)\n- **Purpose**: Draws the path with color gradient effect\n- **Location**: `lib/presentation/widgets/hex_grid/path_painter.dart`\n- **Interfaces**:\n  - `void paint(Canvas canvas, List<HexCell> path)` - Draw path\n- **Dependencies**: None\n- **Requirements**: REQ-003\n\n### GameScreen (UI)\n- **Purpose**: Main game screen with grid and reset button\n- **Location**: `lib/presentation/screens/game/game_screen.dart`\n- **Interfaces**: None (top-level screen)\n- **Dependencies**: HexGridWidget, GameEngine (via Provider)\n- **Requirements**: REQ-006, REQ-007\n\n### REST API Server (Debug)\n- **Purpose**: HTTP endpoints for AI agent interaction\n- **Location**: `lib/debug/api/server.dart`\n- **Endpoints**:\n  - `GET /api/game/state` - Returns GameState as JSON\n  - `POST /api/game/move` - Body: `{\"q\": int, \"r\": int}` - Execute move\n  - `POST /api/game/reset` - Reset level\n- **Dependencies**: GameEngine, shelf\n- **Requirements**: REQ-008\n\n### CLI Runner (Debug)\n- **Purpose**: Command-line interface for level validation\n- **Location**: `lib/debug/cli/cli_runner.dart`\n- **Commands**:\n  - `validate --level <json>` - Validate level solvability\n- **Dependencies**: LevelValidator, args\n- **Requirements**: REQ-009\n\n## Data Models\n\n### HexCell\n```dart\nclass HexCell {\n  final int q;           // Axial q coordinate (-size to +size)\n  final int r;           // Axial r coordinate (-size to +size)\n  final int? checkpoint; // 1, 2, 3... or null\n  bool visited;          // Mutable: path tracking\n\n  // Computed: pixel position for rendering\n  Offset toPixel(double cellSize);\n\n  // Computed: list of 6 adjacent cell coordinates\n  List<(int, int)> get neighbors;\n}\n```\n\n### HexEdge\n```dart\n/// Represents a wall between two adjacent cells.\n/// Uses canonical ordering for consistent equality.\nclass HexEdge {\n  final (int, int) cell1;  // (q, r) - always the \"lesser\" cell\n  final (int, int) cell2;  // (q, r) - always the \"greater\" cell\n\n  /// Factory that ensures canonical ordering\n  factory HexEdge((int, int) a, (int, int) b) {\n    // Order by q first, then by r\n    if (a.$1 < b.$1 || (a.$1 == b.$1 && a.$2 < b.$2)) {\n      return HexEdge._(a, b);\n    }\n    return HexEdge._(b, a);\n  }\n\n  /// Check if this edge connects given cells\n  bool connects((int, int) a, (int, int) b);\n\n  // For JSON serialization\n  Map<String, dynamic> toJson();\n  factory HexEdge.fromJson(Map<String, dynamic> json);\n}\n```\n\n### Level\n```dart\nclass Level {\n  final String id;                       // Canonical hash (computed)\n  final int size;\n  final Map<(int, int), HexCell> cells;  // Indexed by (q, r)\n  final Set<HexEdge> walls;              // Blocked edges\n  final int checkpointCount;\n\n  HexCell? getCell(int q, int r);\n  HexCell get startCell;  // Checkpoint 1\n  HexCell get endCell;    // Highest checkpoint\n\n  /// Check if movement between two cells is blocked by a wall\n  bool hasWall((int, int) from, (int, int) to) {\n    return walls.contains(HexEdge(from, to));\n  }\n\n  /// Get passable neighbors (adjacent cells without walls)\n  List<HexCell> getPassableNeighbors(HexCell cell);\n\n  /// Compute deterministic hash for level identity\n  /// Hash is based on: size, sorted checkpoint positions, sorted wall edges\n  /// Used for: DB primary key, duplicate detection, daily challenge matching\n  String computeHash() {\n    // 1. Encode size\n    // 2. Encode checkpoints as sorted list of (q, r, number)\n    // 3. Encode walls as sorted list of canonical edges\n    // 4. SHA-256 hash of combined data\n    // Returns: first 16 chars of hex hash\n  }\n}\n```\n\n### GameState\n```dart\nclass GameState {\n  final Level level;\n  final GameMode mode;               // daily or practice\n  final List<HexCell> path;\n  final int nextCheckpoint;\n  final DateTime? startTime;\n  final DateTime? endTime;\n\n  bool get isStarted => path.isNotEmpty;\n  bool get isComplete => endTime != null;\n  Duration? get elapsedTime;\n\n  // For leaderboard submission (future)\n  bool get canSubmitToLeaderboard => mode == GameMode.daily && isComplete;\n\n  // Immutable state updates\n  GameState copyWith({...});\n}\n```\n\n### GameMode\n```dart\nenum GameMode {\n  daily,     // Globally shared level - eligible for leaderboard\n  practice,  // Locally generated - no leaderboard\n}\n```\n\n### API Response Models\n```dart\nclass GameStateResponse {\n  final String levelId;              // Level hash (for deduplication/leaderboard)\n  final String mode;                 // \"daily\" or \"practice\"\n  final int gridSize;\n  final List<CellResponse> cells;\n  final List<WallResponse> walls;    // List of blocked edges\n  final List<PathSegment> path;\n  final int nextCheckpoint;\n  final bool isComplete;\n  final int? elapsedMs;\n  final bool canSubmitToLeaderboard; // true if daily mode and complete\n}\n\nclass CellResponse {\n  final int q;\n  final int r;\n  final int? checkpoint;\n  final bool visited;\n}\n\nclass WallResponse {\n  final int q1, r1;  // First cell\n  final int q2, r2;  // Second cell\n}\n\nclass MoveRequest {\n  final int q;\n  final int r;\n}\n\nclass MoveResponse {\n  final bool success;\n  final String? error;    // e.g., \"wall_blocked\", \"already_visited\", \"not_adjacent\"\n  final GameStateResponse? state;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Invalid Move Attempt (UI)**\n   - **Handling**: PathValidator returns false, move ignored silently\n   - **User Impact**: No visual change, path stays as-is\n\n2. **Wall Blocked Move (UI)**\n   - **Handling**: PathValidator detects wall, move ignored\n   - **User Impact**: Optional visual feedback (wall highlight)\n\n3. **Invalid Move Attempt (API)**\n   - **Handling**: Return 400 with error JSON `{\"error\": \"Invalid move\", \"reason\": \"wall_blocked|already_visited|not_adjacent|wrong_checkpoint\"}`\n   - **User Impact**: AI agent receives structured error with specific reason\n\n4. **Level Load Failure**\n   - **Handling**: Fall back to hardcoded default level\n   - **User Impact**: Game still playable, log warning\n\n5. **API Server Startup Failure**\n   - **Handling**: Log error, continue without API (UI-only mode)\n   - **User Impact**: Game works, API unavailable\n\n## Testing Strategy\n\n### Unit Testing\n- **HexEdge**: Test canonical ordering, equality, connects() method\n- **PathValidator**: Test adjacency, wall blocking, checkpoint order validation\n- **GameEngine**: Test move, undo, reset state transitions, wall-blocked moves\n- **LevelValidator**: Test solvability detection, solution finding with walls\n- **Coverage target**: 80% for domain layer\n\n### Integration Testing\n- **REST API**: Test all endpoints with mock GameEngine\n- **CLI**: Test validate command with sample levels\n\n### End-to-End Testing\n- **Web gameplay**: Complete a level via touch/mouse\n- **API gameplay**: Complete a level via REST API calls\n\n### Test File Structure\n```\ntest/\n├── domain/\n│   ├── models/\n│   │   ├── hex_cell_test.dart\n│   │   ├── hex_edge_test.dart      # Wall/edge model tests\n│   │   ├── level_test.dart\n│   │   └── game_state_test.dart\n│   └── services/\n│       ├── path_validator_test.dart  # Includes wall-blocking tests\n│       ├── game_engine_test.dart\n│       └── level_validator_test.dart\n├── debug/\n│   ├── api/\n│   │   └── server_test.dart\n│   └── cli/\n│       └── cli_runner_test.dart\n└── presentation/\n    └── widgets/\n        └── hex_grid_widget_test.dart\n```\n",
  "fileStats": {
    "size": 14716,
    "lines": 457,
    "lastModified": "2025-11-27T21:59:19.132Z"
  },
  "comments": []
}